{
 * This unit was generated automatically. It incorporates a selection of source
 * code taken from the Code Snippets Database at
 * https://github.com/delphidabbler/code-snippets.
 *
 * The unit is copyright © 2005-2025 by Peter Johnson & Contributors and is
 * licensed under the MIT License (https://opensource.org/licenses/MIT).
 *
 * Generated on : Tue, 21 Jan 2025 15:32:09 GMT.
 * Generated by : DelphiDabbler CodeSnip Release 4.24.0.
 *
 * The latest version of CodeSnip is available from the CodeSnip GitHub project
 * at https://github.com/delphidabbler/codesnip.
 *
 * Changes from generated unit:
 *
 *   - Changed unit names to be fully scoped
 *   - Removed unit name qualifiers of types and functions / procedure
 *   - Removed unused conditionally defined code
 *   - Fixed memory leak in Mode function
}


unit Meany.AverageFns;

interface

uses
  System.SysUtils,
  System.Math,
  System.Generics.Collections,
  System.Generics.Defaults,
  System.Types;

{
  Returns the arithmetic mean of an array of Double values.
  EArgumentException is raised if the array is empty.
}
function ArithmeticMean(const A: array of Double): Double; overload;

{
  Returns the geometric mean of an array of positive Double values.
  EArgumentException is raised if the array is empty while
  EArgumentOutOfRangeException is raised if any array element is not positive.
}
function GeometricMean(const A: array of Double): Double; overload;

{
  Returns the harmonic mean of an array of positive Double values.
  EArgumentException is raised if the array is empty or if any array element is
  not positive.
}
function HarmonicMean(const A: array of Double): Double; overload;

{
  Checks if the given array of integers A has a mode and returns True if so.
  Raises EArgumentException if A has fewer than two elements.
}
function HasMode(const A: array of Integer): Boolean;

{
  Returns the logarithmic mean of two positive floating point values, X and Y.
  Raises EArgumentException if either X or Y is not positive.
}
function LogarithmicMean(const X, Y: Double): Double;

{
  Returns the median of an array of floating point values.
  Raises an EArgumentException exception if the array is empty.
}
function Median(A: array of Double): Double; overload;

{
  Calculates the mode of array A of integer data. Returns an array containing
  the mode or modes of the data.
  If the data has a single mode, then a single element array containing the mode
  is returned. If the data is multi-modal then all the modes are returned. If
  all data items occur with equal frequency then an array of all unique data
  items is returned. The returned data is sorted in ascending order.
  Raises EArgumentException if A has fewer than two elements.
}
function Mode(const A: array of Integer): TArray<Integer>;

{
  Calculates the mode of array A of integer data. Returns an array containing
  the mode or modes of the data, if any.
  If the data has a single mode, then a single element array containing the mode
  is returned. If the data is multi-modal then all the modes are returned,
  sorted in ascending order. If all data items occur with equal frequency, and
  not all data items are the same, then there is no mode and an empty array is
  returned.
  Raises EArgumentException if A has fewer than two elements.
}
function ModeAlt(const A: array of Integer): TArray<Integer>;

{
  Returns the number of modes of integer array A.
  Raises EArgumentException if A has fewer than two elements.
}
function ModeCount(const A: array of Integer): Integer;

{
  Returns the power mean of the elements of Double array Values, with exponent
  Lambda.
  An EArgumentException is raised if the array is empty, if any array element is
  negative or if Lambda is zero.
}
function PowerMean(const A: array of Double; const Lambda: Double): Double;
  overload;

{
  Calculates the root mean square of the elements of Double array A.
  Raises EArgumentException if A is empty.
}
function RMS(const A: array of Double): Double; overload;

{
  Calculates the statistical total sum of squares of the elements of Double
  array A.
  EArgumentException is raised if A is empty.
}
function TSS(const A: array of Double): Double; overload;

{
  Calculates and returns the weighted average of the Double elements of array
  Values where each element is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; Values & Weights must
  have the same number of elements; all elements of Weights must be
  non-negative, with at least one element being non-zero.
}
function WeightedArithmeticMean(const Values: array of Double;
  const Weights: array of Double): Double; overload;

{
  Calculates and returns the weighted geometric mean of the array Values of
  positive Double values where each element is weighted by the corresponding
  element in the array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; all elements of Values
  must be positive; Values & Weights must have the same number of elements; all
  elements of Weights must be non-negative, with at least one element being
  non-zero.
}
function WeightedGeometricMean(const Values: array of Double;
  const Weights: array of Double): Double; overload;

{
  Calculates and returns the weighted harmonic mean of the array Values of
  positive Double values where each element is weighted by the corresponding
  element in the array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; all elements of Values
  must be positive; Values & Weights must have the same number of elements; all
  elements of Weights must be non-negative, with at least one element being
  non-zero.
}
function WeightedHarmonicMean(const Values: array of Double;
  const Weights: array of Double): Double; overload;

{
  Returns the weighted power mean of the elements of Double array Values, with
  exponent Lambda. Each term is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; no element of Values may
  be negative; Values & Weights must have the same number of elements; all
  elements of Weights must be non-negative, with at least one element being
  non-zero; Lambda must not be zero.
}
function WeightedPowerMean(const Values, Weights: array of Double;
  const Lambda: Double): Double; overload;

implementation

function CountOccurrences(const A: array of Integer):
  TArray<TPair<Integer,Cardinal>>; forward;
function NormaliseByWeight(const A: array of Double): TDoubleDynArray; overload;
  forward;
function SumOfLogs(const A: array of Double): Double; overload;
  forward;
function SumOfReciprocals(const A: array of Double): Double; overload;
  forward;

{
  Returns the arithmetic mean of an array of Double values.
  EArgumentException is raised if the array is empty.
}
function ArithmeticMean(const A: array of Double): Double; overload;
var
  X: Double;
begin
  if Length(A) = 0 then
    raise EArgumentException.Create('Array is empty');
  Result := 0.0;
  for X in A do
    Result := Result + X / Length(A);
end;

{
  Calculates the number of occurrences of each unique element of array A. An
  array of TPair<Integer,Cardinal> values is returned, where the Key field of
  each TPair element is the integer and the Value field is the number of times
  the integer occurs in A. The returned array is sorted on the Key field.
  Raises EArgumentException if A is empty.
}
function CountOccurrences(const A: array of Integer):
  TArray<TPair<Integer,Cardinal>>;
var
  OccurrenceMap: TDictionary<Integer,Cardinal>;
  Elem: Integer;
  OccurrencesOfX: Cardinal;

  procedure SortResult(var A: array of TPair<Integer,Cardinal>);
  var
    Comparer: IComparer<TPair<Integer,Cardinal>>;
  begin
    //!! Fixes memory leak caused by constructing comparer object in the
    //!! TArray.Sort<T> method call.
    Comparer := TDelegatedComparer<TPair<Integer,Cardinal>>.Create(
      function (const Left, Right: TPair<Integer,Cardinal>): Integer
      begin
        Result := Left.Key - Right.Key;
      end
    );
    TArray.Sort<TPair<Integer,Cardinal>>(A, Comparer);
    //  TArray.Sort<TPair<Integer,Cardinal>>(
    //    A,
    //    TDelegatedComparer<TPair<Integer,Cardinal>>.Create(
    //      function (const Left, Right: TPair<Integer,Cardinal>): Integer
    //      begin
    //        Result := Left.Key - Right.Key;
    //      end
    //    )
    //  );
  end;

begin
  if Length(A) = 0 then
    raise EArgumentException.Create('Array is empty');
  OccurrenceMap := TDictionary<Integer,Cardinal>.Create;
  try
    for Elem in A do
    begin
      if OccurrenceMap.TryGetValue(Elem, OccurrencesOfX) then
        Inc(OccurrencesOfX)
      else
        OccurrencesOfX := 1;
      OccurrenceMap.AddOrSetValue(Elem, OccurrencesOfX);
    end;
    Result := OccurrenceMap.ToArray;
    SortResult(Result);
  finally
    OccurrenceMap.Free;
  end;
end;

{
  Returns the geometric mean of an array of positive Double values.
  EArgumentException is raised if the array is empty while
  EArgumentOutOfRangeException is raised if any array element is not positive.
}
function GeometricMean(const A: array of Double): Double; overload;
begin
  if Length(A) = 0 then
    raise EArgumentException.Create('Array is empty');
  Result := Exp(SumOfLogs(A) / Length(A));
end;

{
  Returns the harmonic mean of an array of positive Double values.
  EArgumentException is raised if the array is empty or if any array element is
  not positive.
}
function HarmonicMean(const A: array of Double): Double; overload;
begin
  Result := Length(A) / SumOfReciprocals(A);
end;

{
  Checks if the given array of integers A has a mode and returns True if so.
  Raises EArgumentException if A has fewer than two elements.
}
function HasMode(const A: array of Integer): Boolean;
var
  OccurrenceCounts: TArray<TPair<Integer,Cardinal>>;
  KV: TPair<Integer,Cardinal>;
  MaxCount: Cardinal;
begin
  if Length(A) <= 1 then
    raise EArgumentException.Create(
      'At least two values required to calculate a mode'
    );
  Result := False;
  OccurrenceCounts := CountOccurrences(A);
  if Length(OccurrenceCounts) = 1 then
    // all data items have the same value: has mode
    Exit(True);
  MaxCount := 0;
  for KV in OccurrenceCounts do
    if KV.Value > MaxCount then
      MaxCount := KV.Value;
  for KV in OccurrenceCounts do
    if KV.Value < MaxCount then
      // at least one value is not the mode => mode exists
      Exit(True);
end;

{
  Returns the logarithmic mean of two positive floating point values, X and Y.
  Raises EArgumentException if either X or Y is not positive.
}
function LogarithmicMean(const X, Y: Double): Double;
begin
  if (X <= 0) or (Y <= 0) then
    raise EArgumentException.Create(
      'Parameters X & Y must both be positive'
    );
  if SameValue(X, Y) then
    Result := X
  else
    Result := (Y - X) / (Ln(Y) - Ln(X));
end;

{
  Returns the median of an array of floating point values.
  Raises an EArgumentException exception if the array is empty.
}
function Median(A: array of Double): Double; overload;
var
  MiddleLo: Integer;
begin
  if Length(A) = 0 then
    raise EArgumentException.Create('Array is empty');
  // optimisations for array lengths 1 & 2 to avoid sorting
  if Length(A) = 1 then
    Exit(A[0]);
  if Length(A) = 2 then
    Exit((A[0] + A[1]) / 2.0);
  TArray.Sort<Double>(A); // using standard comparer
  MiddleLo := Length(A) div 2 - 1;
  if Odd(Length(A)) then
    Result := A[MiddleLo + 1]
  else
    Result := (A[MiddleLo] + A[MiddleLo + 1]) / 2.0;
end;

{
  Calculates the mode of array A of integer data. Returns an array containing
  the mode or modes of the data.
  If the data has a single mode, then a single element array containing the mode
  is returned. If the data is multi-modal then all the modes are returned. If
  all data items occur with equal frequency then an array of all unique data
  items is returned. The returned data is sorted in ascending order.
  Raises EArgumentException if A has fewer than two elements.
}
function Mode(const A: array of Integer): TArray<Integer>;
var
  OccurrenceCounts: TArray<TPair<Integer,Cardinal>>;
  Modes: TList<Integer>;
  KV: TPair<Integer,Cardinal>;
  MaxCount: Cardinal;
begin
  if Length(A) <= 1 then
    raise EArgumentException.Create(
      'At least two values required to calculate the mode'
    );
  MaxCount := 0;
  OccurrenceCounts := CountOccurrences(A);
  for KV in OccurrenceCounts do
    if KV.Value > MaxCount then
      MaxCount := KV.Value;
  Modes := TList<Integer>.Create;
  try
    for KV in OccurrenceCounts do
      if KV.Value = MaxCount then
        Modes.Add(KV.Key);
    Modes.Sort;
    Result := Modes.ToArray;
  finally
    Modes.Free;
  end;
end;

{
  Calculates the mode of array A of integer data. Returns an array containing
  the mode or modes of the data, if any.
  If the data has a single mode, then a single element array containing the mode
  is returned. If the data is multi-modal then all the modes are returned,
  sorted in ascending order. If all data items occur with equal frequency, and
  not all data items are the same, then there is no mode and an empty array is
  returned.
  Raises EArgumentException if A has fewer than two elements.
}
function ModeAlt(const A: array of Integer): TArray<Integer>;
var
  OccurrenceCounts: TArray<TPair<Integer,Cardinal>>;
  Modes: TList<Integer>;
  KV: TPair<Integer,Cardinal>;
  MaxCount: Cardinal;
  HasMode: Boolean;
begin
  if Length(A) <= 1 then
    raise EArgumentException.Create(
      'At least two values required to calculate the mode'
    );
  OccurrenceCounts := CountOccurrences(A);
  if Length(OccurrenceCounts) = 1 then
    // all data items have the same value: result is the sole data value
    Exit(TArray<Integer>.Create(A[0]));
  MaxCount := 0;
  for KV in OccurrenceCounts do
    if KV.Value > MaxCount then
      MaxCount := KV.Value;
  Modes := TList<Integer>.Create;
  HasMode := False;
  try
    for KV in OccurrenceCounts do
      if KV.Value = MaxCount then
        Modes.Add(KV.Key)
      else
        HasMode := True;
    Modes.Sort;
    if HasMode then
      Result := Modes.ToArray
    else
      // the are >= 2 different data items, all of which occur with the same
      // frequency: return empty array
      SetLength(Result, 0);
  finally
    Modes.Free;
  end;
end;

{
  Returns the number of modes of integer array A.
  Raises EArgumentException if A has fewer than two elements.
}
function ModeCount(const A: array of Integer): Integer;
var
  OccurrenceCounts: TArray<TPair<Integer,Cardinal>>;
  KV: TPair<Integer,Cardinal>;
  MaxCount: Cardinal;
  HasMode: Boolean;
begin
  if Length(A) <= 1 then
    raise EArgumentException.Create(
      'At least two values required to calculate a mode'
    );
  OccurrenceCounts := CountOccurrences(A);
  if Length(OccurrenceCounts) = 1 then
    // all data items have the same value: has single mode
    Exit(1);
  MaxCount := 0;
  for KV in OccurrenceCounts do
    if KV.Value > MaxCount then
      MaxCount := KV.Value;
  Result := 0;
  HasMode := False;
  for KV in OccurrenceCounts do
    if KV.Value = MaxCount then
      Inc(Result)
    else
      HasMode := True;
  if not HasMode then
    Result := 0;
end;

{
  Normalises the values in floating point array A so that each value of A is
  mapped to a value in the range [0..1], where the total of all the values is 1.
  The relative weights of the values are preserved.
  An array of the same size as A is returned where each element contains the
  normalised value of the corresponding element of A.
  A must not be empty. All elements of A must be >= 0, with at least one element
  > 0. EArgumentException is raised if these conditions are not met.
}
function NormaliseByWeight(const A: array of Double): TDoubleDynArray;
  overload;
var
  Weight: Double;
  WeightSum: Double;
  Idx: Integer;
begin
  if (Length(A) = 0) then
    raise EArgumentException.Create('Array of weights is empty');
  WeightSum := 0.0;
  for Weight in A do
  begin
    if Sign(Weight) = NegativeValue then
      raise EArgumentException.Create(
        'All weights must be non-negative'
      );
    WeightSum := WeightSum + Weight;
  end;
  if IsZero(WeightSum) then
    raise EArgumentException.Create('Sum of weights is zero');
  SetLength(Result, Length(A));
  for Idx := 0 to Pred(Length(A)) do
    Result[Idx] := A[Idx] / WeightSum;
end;

{
  Returns the power mean of the elements of Double array Values, with exponent
  Lambda.
  An EArgumentException is raised if the array is empty, if any array element is
  negative or if Lambda is zero.
}
function PowerMean(const A: array of Double; const Lambda: Double): Double;
  overload;
var
  Sum: Double;
  X: Double;
begin
  if Length(A) = 0 then
    raise EArgumentException.Create('Array is empty');
  if IsZero(Lambda) then
    raise EArgumentException.Create('Lambda must not be zero');
  Sum := 0.0;
  for X in A do
  begin
    if Sign(X) = NegativeValue then
      raise EArgumentException.Create(
        'All array elements must be non-negative'
      );
    if not IsZero(X) then
      Sum := Sum + Power(X, Lambda);
  end;
  Result := Power(Sum / Length(A), 1 / Lambda);
end;

{
  Calculates the root mean square of the elements of Double array A.
  Raises EArgumentException if A is empty.
}
function RMS(const A: array of Double): Double; overload;
var
  Squares: array of Double;
  Idx: Integer;
begin
  SetLength(Squares, Length(A));
  for Idx := 0 to Pred(Length(A)) do
    Squares[Idx] := A[Idx] * A[Idx];
  // Note: ArithmeticMean raises exception if A is empty
  Result := Power(ArithmeticMean(Squares), 0.5);
end;

{
  Returns the sum of the natural logarithms of each Double floating point
  element of array A.
  All elements of A must be positive. An exception is raised otherwise.
  0.0 is returned if A is empty.
}
function SumOfLogs(const A: array of Double): Double; overload;
resourcestring
  sNotPositive = 'All elements of array A must be > 0';
var
  Elem: Double;
begin
  Result := 0.0;
  for Elem in A do
  begin
    if Sign(Elem) <> PositiveValue then
      raise EArgumentOutOfRangeException.Create(sNotPositive);
    Result := Result + Ln(Elem);
  end;
end;

{
  Calculates the sum of the reciprocal values of all elements of Double array A.
  A must not be empty and all its elements must be positive. EArgumentException
  is raised if either of these conditions is not satisfied.
}
function SumOfReciprocals(const A: array of Double): Double; overload;
var
  Elem: Double;
begin
  if Length(A) = 0 then
    raise EArgumentException.Create('Array is empty');
  Result := 0.0;
  for Elem in A do
  begin
    if Sign(Elem) <> PositiveValue then
      raise EArgumentException.Create('Array values must be > 0');
    Result := Result + 1 / Elem;
  end;
end;

{
  Calculates the statistical total sum of squares of the elements of Double
  array A.
  EArgumentException is raised if A is empty.
}
function TSS(const A: array of Double): Double; overload;
var
  ElemOfA: Double;
  MeanOfA: Double;
begin
  // Note: ArithmeticMean raises an exception if A is empty
  MeanOfA := ArithmeticMean(A);
  Result := 0.0;
  for ElemOfA in A do
    Result := Result + Sqr(ElemOfA - MeanOfA);
end;

{
  Calculates and returns the weighted average of the Double elements of array
  Values where each element is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; Values & Weights must
  have the same number of elements; all elements of Weights must be
  non-negative, with at least one element being non-zero.
}
function WeightedArithmeticMean(const Values: array of Double;
  const Weights: array of Double): Double; overload;
var
  WeightSum: Double;
  Weight: Double;
  Idx: Integer;
begin
  if Length(Values) = 0 then
    raise EArgumentException.Create('Array of values is empty');
  if Length(Values) <> Length(Weights) then
    raise EArgumentException.Create(
      'Number of values and number of weights must be the same'
    );
  WeightSum := 0.0;
  for Weight in Weights do
  begin
    if Sign(Weight) = NegativeValue then
      raise EArgumentException.Create('Weights must all be >= 0');
    WeightSum := WeightSum + Weight;
  end;
  if IsZero(WeightSum) then
    raise EArgumentException.Create('All weights are 0');
  Result := 0.0;
  for Idx := Low(Values) to High(Values) do
    Result := Result + Weights[Idx] * Values[Idx] / WeightSum;
end;

{
  Calculates and returns the weighted geometric mean of the array Values of
  positive Double values where each element is weighted by the corresponding
  element in the array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; all elements of Values
  must be positive; Values & Weights must have the same number of elements; all
  elements of Weights must be non-negative, with at least one element being
  non-zero.
}
function WeightedGeometricMean(const Values: array of Double;
  const Weights: array of Double): Double; overload;
var
  Sum: Double;
  Idx: Integer;
  NormalisedWeights: TDoubleDynArray;
begin
  if Length(Values) = 0 then
    raise EArgumentException.Create('Array of values is empty');
  if Length(Values) <> Length(Weights) then
    raise EArgumentException.Create(
      'Number of values and number of weights must be the same'
    );
  NormalisedWeights := NormaliseByWeight(Weights);
  Sum := 0.0;
  for Idx := 0 to Pred(Length(Values)) do
    Sum := Sum + NormalisedWeights[Idx] * Ln(Values[Idx]);
  Result := Exp(Sum);
end;

{
  Calculates and returns the weighted harmonic mean of the array Values of
  positive Double values where each element is weighted by the corresponding
  element in the array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; all elements of Values
  must be positive; Values & Weights must have the same number of elements; all
  elements of Weights must be non-negative, with at least one element being
  non-zero.
}
function WeightedHarmonicMean(const Values: array of Double;
  const Weights: array of Double): Double; overload;
var
  Sum: Double;
  Idx: Integer;
  NormalisedWeights: TDoubleDynArray;
begin
  if Length(Values) = 0 then
    raise EArgumentException.Create('Array of values is empty');
  if Length(Values) <> Length(Weights) then
    raise EArgumentException.Create(
      'Number of values and number of weights must be the same'
    );
  NormalisedWeights := NormaliseByWeight(Weights);
  Sum := 0.0;
  for Idx := 0 to Pred(Length(Values)) do
    Sum := Sum + NormalisedWeights[Idx] / Values[Idx];
  Result := 1.0 / Sum;
end;

{
  Returns the weighted power mean of the elements of Double array Values, with
  exponent Lambda. Each term is weighted by the corresponding element in the
  array Weights.
  An EArgumentException exception is raised if any of the following
  pre-conditions are not met: Values must be non-empty; no element of Values may
  be negative; Values & Weights must have the same number of elements; all
  elements of Weights must be non-negative, with at least one element being
  non-zero; Lambda must not be zero.
}
function WeightedPowerMean(const Values, Weights: array of Double;
  const Lambda: Double): Double; overload;
var
  NormalisedWeights: TDoubleDynArray;
  PowerSum: Double;
  Idx: Integer;
  Value: Double;
  Weight: Double;
begin
  if Length(Values) = 0 then
    raise EArgumentException.Create('Array of values is empty');
  if Length(Values) <> Length(Weights) then
    raise EArgumentException.Create(
      'Number of values and number of weights must be the same'
    );
  if IsZero(Lambda) then
    raise EArgumentException.Create('Lambda must not be zero');
  NormalisedWeights := NormaliseByWeight(Weights);
  PowerSum := 0.0;
  for Idx := 0 to Pred(Length(Values)) do
  begin
    Value := Values[Idx];
    Weight := NormalisedWeights[Idx];
    if Sign(Value) = NegativeValue then
      raise EArgumentException.Create(
        'All values must be non-negative'
      );
    if not IsZero(Value) and not IsZero(Weight) then
      PowerSum := PowerSum + Weight * Power(Value, Lambda);
  end;
  if not IsZero(PowerSum) then
    Result := Power(PowerSum, 1 / Lambda)
  else
    Result := 0.0;
end;

end.

